### 꼬리 재귀의 제거

기존 recur(int n) 메서드 에서 recur(n-2)부분이 꼬리에서 재귀호출하는 부분인데

⇒ n = n-2로 업데이트 

하면 꼬리가 사라진다 

```java
while(n > 0){
	recur(n - 1);
	System.out.println(n);
	n = n - 2;
	}
```

### 재귀의 제거

recur(n-1)부분을 제거하기가 쉽지 않음

ex) n이 4라면 recur(3)이 처리되지 않으면 n4를 잠깐 저장해 두고 recur(3)이 완료되면 값을 꺼낸다

⇒ 스택 사용

```java
 static void recur(int n){
        IntStack s = new IntStack(n);

        while(true){
            if(n > 0){
                s.push(n);
                n = n - 1;
                continue;
            }
            if(!s.isEmpty()){
                n = s.pop();
                System.out.println(n);
                n = n - 2;
                continue;
            }
            break;
        }
    }
```

### 메모화

recur 메서드는 실행 과정에서 같은 계산을 여러번 반복 수행

recur(n)에서 n 값이 커지면 반복하는 계산 횟수가 늘어난다 

⇒ 메모화 기법 사용하면 동일한 계산을 사용하지 않고 1회만 수행 (메모해둔다)

### 하노이의 탑

: 원반을 최소 횟수로 옮기기 위한 알고리즘

```sql
 //no개의 원반을 x번 기둥에서 y번 기둥으로 옮김
    static void move(int no, int x, int y){
        if(no > 1){
            move(no - 1, x , 6 - x - y);
        }
        System.out.printf("원반[%d]을(를) %d번 기둥에서 %d번 기둥으로 옮김\n", no, x, y);

        if(no > 1){
            move(no - 1, 6 - x - y , y);
        }
    }
```

### 8퀸 문제

: 서로 공격하여 잡을 수 없도록 8개의 퀸을 8x8체스판에 놓아라 

1. 퀸 배치 
    
    ⇒ 첫 퀸 64 두번째 퀸 63 ….
    
    64 x 63 x 62 x 61 x 60 x 59 x 58 x 57 의 경우의 수에서 8퀸문제 조건을 만족하는것 조사
    
2. 각 열에만 퀸 배치 
    
    ⇒ 같은 행에서 공격할 수 잇다
    
3. 각 행에 퀸 1개만 배치 

- 분기 조작

분기 : 가지 뻗어나가듯이 문제를 나누어 푸는 과정 

i열에 놓인 퀸의 위치가 j이면  pos[i] = j 

ex) pos[0]의 값이 0 이면 0열의 퀸이 0행에 배치, pos[1] d의 값이 4면 1열의 퀸이 4행에 배치 

0 ~ 7까지 해서 열에 퀸이 하나있도록 배치한다 

- 분기 한정법

분지 조작으로 퀸을 배치하는 조합을 모두 나열했으나 8퀸 문제 답을 구할수 없다 

한정을 위한 규칙 ⇒ 각 행에 퀸을 1개만 배치 

대각선도 고려하여 8퀸문제 해결
