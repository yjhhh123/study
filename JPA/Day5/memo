### Sequence 전략

- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스)
- 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용
    
    ![스크린샷 2025-03-05 오후 4.16.57.png](attachment:547db89d-76cc-4d48-9a66-ecff6d60ca9f:스크린샷_2025-03-05_오후_4.16.57.png)
    
- strategy = GenerationType.SEQUENCE, generator = “MEMBER_SEQ_GENERATOR”)
- Id에 위와 같이 매핑 되어 있는 것을 보고 “Member_SEQ”에서 값을 가져온다고 한다
- 그러면 call next value for MEMBER_SEQ 실행 pk 값을 가져오고 영속성 컨텍스트에 저장한다(버퍼링 가능)
- db 인스턴스 쿼리는 안날라 간다 커밋하는 시점에 날라간다
- 너무 네트워크 왔다 갔다 하지 않냐 성능에 문제가 있지 않냐 (allocationSize)
- allocationSize = 50(default) 를 하면 50까지 미리 호출 한다 그럼 다음 호출은 1번 하지만 100번때로 간다

![스크린샷 2025-03-05 오후 4.17.09.png](attachment:3626724a-9a37-49e0-9f92-dbf721c5f871:스크린샷_2025-03-05_오후_4.17.09.png)

### Table 전략

- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략
- 장점 : 모든 DB에 적용 가능
- 단점 : 성능

![스크린샷 2025-03-05 오후 3.59.25.png](attachment:a1374319-e3e7-4b13-8c84-4ef547352657:스크린샷_2025-03-05_오후_3.59.25.png)

⇒ 잘 사용하지는 않는다 ~

### 권장하는 식별자 전략

- 기본 키 제약 조건 : null 아님, 유일, 변하면 안된다
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자.
- 예를 들어 주민등록번호도 기본 키로 적절하지 않다
- 권장 : Long 형 + 대체키 + 키 생성 전략 사용
- auto-increament, sequence, uuid 비지니스를 키로 가져오는 것은 권장 x

### Identity 전략

- identity 전략은 id값을 넣지 않고 넘겨주면(null로) db에서 값을 세팅 해준다
- db에 값이 들어가 봐야 id값을 알 수 있다
- 영속성 컨텍스트에서 관리가 되려면 pk값이 있어야한다
    
    ![스크린샷 2025-03-05 오후 4.07.24.png](attachment:25e7eb5e-af2c-4c4d-b992-3428d0ad59fe:스크린샷_2025-03-05_오후_4.07.24.png)
    
- 여기서 @Id가 DB의 PK값이다
- 하지만 Identity는 DB에 값을 넣기 전까지 이 값(PK)을 모른다
- 이때만 특수하게 em.persist호출하면 insert쿼리를 날린다 (커밋할 때 쿼리가 날라가지 않고)
- 값을 넣어서 insert가 나가는데 member.id를 알 수 있다 (jdbc 내부로 값을 알아오게 설게 되어 있다)
- insert 하면서 PK값을 가져와서 쓴다

- 기본 키 생성을 데이터베이스에 위임
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용
(예: MySQL의 AUTO_ INCREMENT)
- JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행
- AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음
- IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회

### 데이터 중심 설계의 문제점

![스크린샷 2025-03-05 오후 7.07.58.png](attachment:16b61f1a-f0a5-4e64-967f-c7573e3678f2:스크린샷_2025-03-05_오후_7.07.58.png)

- 현재 방식은 객체 설계를 테이블 설계에 맞춰 설계에 맞춘 방식
- 테이블의 외래키를 객체에 그대로 가져옴
- 객체 그래프 탐색이 불가능
- 참조가 없으므로 UML도 잘못됨

### 연관관계 매핑 기초

- 객체와 테이블 연관관계의 차이를 이해
- 객체의 참조와 테이블의 외래 키를 매핑
- 용어 이해
    - 방향 : 단방향, 양방향
    - 다중성 : 다대일(N : 1), 일대다(1 : N), 일대일(1 : 1), 다대다(N : M) 이해
    - 연관관계의 주인 : 객체 양방향 연관관계는 관리주인이 필요
    

### 예제 시나리오

- 회원과 팀이 있다.
- 회원은 하나의 팀에만 소속될 수 있다.
- 회원과 팀은 다대일 관계다.

![스크린샷 2025-03-05 오후 8.31.12.png](attachment:055c27c4-fb0c-4cee-990d-2d6ca1c76fe9:스크린샷_2025-03-05_오후_8.31.12.png)

### 단방향  연관관계

![스크린샷 2025-03-05 오후 9.22.37.png](attachment:0d20fba1-515c-4dfb-b538-7673703a07e1:스크린샷_2025-03-05_오후_9.22.37.png)

```java
@ManyToOne //멤버 입장은 many이고 팀 입장으로는 1이므로
@JoinColumn(name = "TEAM_ID") //join 해야하는 컬럼이 뭐냐
private Team team;
```

1. 관계가 뭔지 어노테이션
2. 조인하는 컬럼이 뭔지 어노테이션 

⇒ 두개 하면 매핑 끝

![스크린샷 2025-03-05 오후 9.27.49.png](attachment:2b2964ad-8390-4542-aa2b-2cc6e1b274b5:스크린샷_2025-03-05_오후_9.27.49.png)

: 자유롭게 member에서 team의 정보를 가져올 수 있다
